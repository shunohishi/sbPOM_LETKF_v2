!-------------------------------------------------------------------------------

subroutine nino34_index(im,jm,lon,lat,anom,index)

  use mod_rmiss
  implicit none

  !---Parameter
  real(kind = 8),parameter :: slon=190.d0,elon=240.d0
  real(kind = 8),parameter :: slat=-5.d0,elat=5.d0
  
  !---Common
  integer i,j

  real(kind = 8) pass,miss
  
  !---IN
  integer,intent(in) :: im,jm

  real(kind = 8),intent(in) :: lon(im),lat(jm)
  real(kind = 8),intent(in) :: anom(im,jm)

  !---OUT
  real(kind = 8),intent(out) :: index

  index=0.d0
  pass=0.d0
  miss=0.d0
  
  do j=1,jm

     if(lat(j) < slat .or. elat < lat(j)) cycle

     do i=1,im

        if(lon(i) < slon .or. elon < lon(i)) cycle
        if(anom(i,j) == rmiss) cycle

        index=index+anom(i,j)
        pass=pass+1.d0
        miss=miss+1.d0

     end do
  end do
        
  if(pass == 0.d0)then
     index=rmiss
  else
     index=index/pass
  end if
  
end subroutine nino34_index

!---------------------------------------------------------------------------------------

subroutine iod_index(im,jm,lon,lat,anom,index)

  use mod_rmiss
  implicit none

  !---Parameter
  !west
  real(kind = 8),parameter :: slon_w=50.d0,elon_w=70.d0
  real(kind = 8),parameter :: slat_w=-10.d0,elat_w=10.d0
  !east
  real(kind = 8),parameter :: slon_e=90.d0,elon_e=110.d0
  real(kind = 8),parameter :: slat_e=-10.d0,elat_e=10.d0
  
  !---Common
  integer i,j

  real(kind = 8) index_w
  real(kind = 8) pass_w,miss_w
  real(kind = 8) index_e
  real(kind = 8) pass_e,miss_e
  
  !---IN
  integer,intent(in) :: im,jm

  real(kind = 8),intent(in) :: lon(im),lat(jm)
  real(kind = 8),intent(in) :: anom(im,jm)

  !---OUT
  real(kind = 8),intent(out) :: index

  !---WEST
  index_w=0.d0
  pass_w=0.d0
  miss_w=0.d0

  do j=1,jm

     if(lat(j) < slat_w .or. elat_w < lat(j)) cycle

     do i=1,im

        if(lon(i) < slon_w .or. elon_w < lon(i)) cycle
        if(anom(i,j) == rmiss) cycle

        index_w=index_w+anom(i,j)
        pass_w=pass_w+1.d0
        miss_w=miss_w+1.d0

     end do
  end do

  if(pass_w == 0.d0)then
     index_w=rmiss
  else
     index_w=index_w/pass_w
  end if

  !---EAST
  index_e=0.d0
  pass_e=0.d0
  miss_e=0.d0
  
  do j=1,jm

     if(lat(j) < slat_e .or. elat_e < lat(j)) cycle

     do i=1,im

        if(lon(i) < slon_e .or. elon_e < lon(i)) cycle
        if(anom(i,j) == rmiss) cycle

        index_e=index_e+anom(i,j)
        pass_e=pass_e+1.d0
        miss_e=miss_e+1.d0

     end do
  end do
        
  if(pass_e == 0.d0)then
     index_e=rmiss
  else
     index_e=index_e/pass_e
  end if

  !---INDEX
  if(index_w == rmiss .or. index_e == rmiss)then
     index=rmiss
  else
     index=index_w-index_e
  end if
  
end subroutine iod_index

!---------------------------------------------------------------------------------------

subroutine atlantic_nino_index(im,jm,lon,lat,anom,index)

  use mod_rmiss
  implicit none

  !---Parameter
  real(kind = 8),parameter :: slon=340.d0,elon=360.d0
  real(kind = 8),parameter :: slat=-3.d0,elat=3.d0
  
  !---Common
  integer i,j

  real(kind = 8) pass,miss
  
  !---IN
  integer,intent(in) :: im,jm

  real(kind = 8),intent(in) :: lon(im),lat(jm)
  real(kind = 8),intent(in) :: anom(im,jm)

  !---OUT
  real(kind = 8),intent(out) :: index

  index=0.d0
  pass=0.d0
  miss=0.d0
  
  do j=1,jm

     if(lat(j) < slat .or. elat < lat(j)) cycle

     do i=1,im

        if(lon(i) < slon .or. elon < lon(i)) cycle
        if(anom(i,j) == rmiss) cycle
        
        index=index+anom(i,j)
        pass=pass+1.d0
        miss=miss+1.d0

     end do
  end do
        
  if(pass == 0.d0)then
     index=rmiss
  else
     index=index/pass
  end if
  
end subroutine atlantic_nino_index

!-------------------------------------------------------------------------

subroutine normalization(index,index_norm)

  use setting
  implicit none

  !---Common
  integer iyr
  
  real(kind = 8) ave,std
  
  !---IN
  real(kind = 8) index(syr:eyr)

  !---OUT
  real(kind = 8) index_norm(syr:eyr)

  !---Ave
  ave=0.d0

  do iyr=syr,eyr
     ave=ave+index(iyr)
  end do

  ave=ave/dble(eyr-syr+1)

  !---Standard deviation
  std=0.d0

  do iyr=syr,eyr
     std=std+(index(iyr)-ave)**2
  end do

  std=sqrt(std/dble(eyr-syr))

  !---Normalization
  do iyr=syr,eyr
     index_norm(iyr)=(index(iyr)-ave)/std
  end do

  write(*,*) "Normalization"
  write(*,*) "Ave.=",ave,"STD=",std
  
end subroutine normalization
